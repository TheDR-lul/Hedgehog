// –£–±–∏—Ä–∞–µ–º –Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã
// use crate::hedger::Hedger; // Hedger –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ /unhedge
// use crate::models::HedgeRequest;
use crate::exchange::Exchange;
use crate::models::UnhedgeRequest; // –û—Å—Ç–∞–≤–ª—è–µ–º UnhedgeRequest –¥–ª—è /unhedge
// –î–æ–±–∞–≤–ª—è–µ–º UserState –∏ MessageId
use super::{Command, StateStorage, UserState};
use teloxide::prelude::*;
// –î–æ–±–∞–≤–ª—è–µ–º InlineKeyboardButton, InlineKeyboardMarkup, MessageId
use teloxide::types::{InlineKeyboardButton, InlineKeyboardMarkup, MessageId};
use teloxide::utils::command::BotCommands;
use tracing::{warn, error, info}; // –ò—Å–ø–æ–ª—å–∑—É–µ–º tracing –¥–ª—è –ª–æ–≥–æ–≤

pub async fn handle_command<E>(
    bot: Bot,
    msg: Message,
    cmd: Command,
    mut exchange: E,
    state_storage: StateStorage,
) -> anyhow::Result<()>
where
    E: Exchange + Clone + Send + Sync + 'static,
{
    let chat_id = msg.chat.id;
    let message_id = msg.id; // ID —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–æ–º–∞–Ω–¥–æ–π

    // --- –°–±—Ä–æ—Å —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–∏ –Ω–æ–≤–æ–π –∫–æ–º–∞–Ω–¥–µ ---
    let mut previous_bot_message_id: Option<i32> = None;
    {
        let mut state_guard = state_storage
            .write()
            .expect("Failed to acquire write lock on state storage");
        if let Some(old_state) = state_guard.get(&chat_id) {
            // --- –ò–°–ü–†–ê–í–õ–ï–ù–û: –î–æ–±–∞–≤–ª–µ–Ω—ã –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã UserState ---
            previous_bot_message_id = match old_state {
                UserState::AwaitingAssetSelection { last_bot_message_id } => *last_bot_message_id,
                UserState::AwaitingSum { last_bot_message_id, .. } => *last_bot_message_id,
                UserState::AwaitingVolatility { last_bot_message_id, .. } => *last_bot_message_id,
                UserState::AwaitingUnhedgeQuantity { last_bot_message_id, .. } => *last_bot_message_id,
                // –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –≤–µ—Ç–∫–∏, –æ–Ω–∏ –Ω–µ —Ö—Ä–∞–Ω—è—Ç ID
                UserState::None => None,
                // –ï—Å–ª–∏ –ø–æ—è–≤—è—Ç—Å—è –¥—Ä—É–≥–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ö—Ä–∞–Ω—è—Ç ID, –∏—Ö —Ç–æ–∂–µ —Å—é–¥–∞
                // –ù–∞–ø—Ä–∏–º–µ—Ä: UserState::Status => None, UserState::Wallet => None, ...
            };
        }
        if !matches!(state_guard.get(&chat_id), Some(UserState::None) | None) {
             info!("Resetting user state for {} due to new command.", chat_id);
             state_guard.insert(chat_id, UserState::None);
        }
    }

    if let Some(bot_msg_id_int) = previous_bot_message_id {
         if let Err(e) = bot.delete_message(chat_id, MessageId(bot_msg_id_int)).await {
            warn!("Failed to delete previous bot message {}: {}", bot_msg_id_int, e);
        }
    }
    // --- –ö–æ–Ω–µ—Ü —Å–±—Ä–æ—Å–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è ---


    match cmd {
        Command::Help => {
            if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
            let kb = InlineKeyboardMarkup::new(vec![
                vec![
                    InlineKeyboardButton::callback("‚úÖ –°—Ç–∞—Ç—É—Å", "status"),
                    InlineKeyboardButton::callback("üíº –ë–∞–ª–∞–Ω—Å", "wallet"),
                ],
                vec![
                    InlineKeyboardButton::callback("ü™ô –ë–∞–ª–∞–Ω—Å –º–æ–Ω–µ—Ç—ã", "balance"),
                    InlineKeyboardButton::callback("‚öôÔ∏è –•–µ–¥–∂", "hedge"), // –ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—ã–±–æ—Ä –∞–∫—Ç–∏–≤–∞
                    InlineKeyboardButton::callback("üõ† –†–∞—Å—Ö–µ–¥–∂", "unhedge"), // –ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—ã–±–æ—Ä –∞–∫—Ç–∏–≤–∞
                    InlineKeyboardButton::callback("üìà Funding", "funding"),
                ],
            ]);
            bot.send_message(chat_id, Command::descriptions().to_string())
                .reply_markup(kb)
                .await?;
        }

        // --- –ö–æ–º–∞–Ω–¥—ã Status, Wallet, Balance –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ---
        Command::Status => {
             if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
            match exchange.check_connection().await {
                Ok(_) => {
                    bot.send_message(chat_id, "‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –±–∏—Ä–∂–µ.").await?;
                }
                Err(e) => {
                     bot.send_message(chat_id, format!("‚ö†Ô∏è –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω, –Ω–æ –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º–∞ —Å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ–º –∫ –±–∏—Ä–∂–µ: {}", e)).await?;
                }
            }
        }
        Command::Wallet => {
             if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
             info!("Fetching wallet balance for chat_id: {}", chat_id);
            match exchange.get_all_balances().await {
                Ok(balances) => {
                    let mut text = "üíº –ë–∞–ª–∞–Ω—Å –∫–æ—à–µ–ª—å–∫–∞:\n".to_string();
                    let mut found_assets = false;
                    let mut sorted_balances: Vec<_> = balances.into_iter().collect();
                    sorted_balances.sort_by_key(|(coin, _)| coin.clone());

                    for (coin, bal) in sorted_balances {
                        if bal.free > 1e-8 || bal.locked > 1e-8 {
                            text.push_str(&format!(
                                "‚Ä¢ {}: Ô∏èfree {:.4}, locked {:.4}\n", // –£–±—Ä–∞–ª–∏ total
                                coin, bal.free, bal.locked
                            ));
                            found_assets = true;
                        }
                    }
                    if !found_assets {
                        text = "‚ÑπÔ∏è –í–∞—à –∫–æ—à–µ–ª–µ–∫ –ø—É—Å—Ç.".to_string();
                    }
                    bot.send_message(chat_id, text).await?;
                }
                Err(e) => {
                    error!("Failed to fetch wallet balance for chat_id: {}: {}", chat_id, e);
                    bot.send_message(chat_id, format!("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å –∫–æ—à–µ–ª—å–∫–∞: {}", e)).await?;
                }
            }
        }
        Command::Balance(arg) => {
             if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
            let sym = arg.trim().to_uppercase();
            if sym.is_empty() {
                bot.send_message(chat_id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /balance <SYMBOL>").await?;
            } else {
                info!("Fetching balance for {} for chat_id: {}", sym, chat_id);
                match exchange.get_balance(&sym).await {
                    Ok(b) => {
                        bot.send_message(
                            chat_id,
                            format!("üí∞ {}: free {:.4}, locked {:.4}", sym, b.free, b.locked), // –£–±—Ä–∞–ª–∏ total
                        ).await?;
                    }
                    Err(e) => {
                         error!("Failed to fetch balance for {} for chat_id: {}: {}", sym, chat_id, e);
                        bot.send_message(chat_id, format!("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å {}: {}", sym, e)).await?;
                    }
                }
            }
        }
        // --- –ö–æ–Ω–µ—Ü –∫–æ–º–∞–Ω–¥ Status, Wallet, Balance ---


        Command::Hedge(arg) => {
            if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
            let symbol = arg.trim().to_uppercase();
            if symbol.is_empty() {
                bot.send_message(chat_id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /hedge <SYMBOL>\n–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É '–•–µ–¥–∂' –∏–∑ /help.").await?;
            } else {
                info!("Starting hedge dialog via command for chat_id: {}, symbol: {}", chat_id, symbol);
                let kb = InlineKeyboardMarkup::new(vec![vec![
                    InlineKeyboardButton::callback("‚ùå –û—Ç–º–µ–Ω–∞", "cancel_hedge"),
                ]]);
                let bot_msg = bot.send_message(
                    chat_id,
                    format!("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É USDT –¥–ª—è —Ö–µ–¥–∂–∏—Ä–æ–≤–∞–Ω–∏—è {}:", symbol),
                )
                .reply_markup(kb)
                .await?;
                {
                    let mut state = state_storage
                        .write()
                        .expect("Failed to acquire write lock on state storage");
                    state.insert(chat_id, UserState::AwaitingSum {
                        symbol: symbol.clone(),
                        last_bot_message_id: Some(bot_msg.id.0),
                    });
                    info!("User state for {} set to AwaitingSum for symbol {}", chat_id, symbol);
                }
            }
        }

        Command::Unhedge(arg) => {
             if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
            let parts: Vec<_> = arg.split_whitespace().collect();
             if parts.len() != 2 {
                bot.send_message(chat_id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /unhedge <QUANTITY> <SYMBOL>").await?;
                 return Ok(());
            }
            let quantity_res = parts[0].parse::<f64>();
            let sym = parts[1].to_uppercase();
            match quantity_res {
                Ok(quantity) if quantity > 0.0 => {
                    info!("Processing /unhedge command for chat_id: {}, quantity: {}, symbol: {}", chat_id, quantity, sym);
                    // –°–æ–∑–¥–∞–µ–º Hedger –∑–¥–µ—Å—å, —Ç–∞–∫ –∫–∞–∫ –∫–æ–º–∞–Ω–¥–∞ –ø—Ä—è–º–∞—è
                    let hedger = crate::hedger::Hedger::new(exchange.clone(), 0.005, 0.001, 30);
                    let waiting_msg = bot.send_message(chat_id, format!("‚è≥ –ó–∞–ø—É—Å–∫–∞—é —Ä–∞—Å—Ö–µ–¥–∂–∏—Ä–æ–≤–∞–Ω–∏–µ {} {}...", quantity, sym)).await?;
                    match hedger.run_unhedge(UnhedgeRequest {
                        sum: quantity,
                        symbol: sym.clone(),
                    }).await {
                        Ok((sold, bought)) => {
                            info!("Unhedge successful for chat_id: {}. Sold spot: {}, Bought fut: {}", chat_id, sold, bought);
                            bot.edit_message_text(
                                waiting_msg.chat.id,
                                waiting_msg.id,
                                format!(
                                    "‚úÖ –†–∞—Å—Ö–µ–¥–∂–∏—Ä–æ–≤–∞–Ω–∏–µ {} {} –∑–∞–≤–µ—Ä—à–µ–Ω–æ:\n\nüü¢ –ü—Ä–æ–¥–∞–Ω–æ —Å–ø–æ—Ç–∞: {:.4}\nüî¥ –ö—É–ø–ª–µ–Ω–æ —Ñ—å—é—á–∞: {:.4}",
                                    quantity, sym, sold, bought,
                                )
                            ).await?;
                        }
                        Err(e) => {
                            error!("Unhedge failed for chat_id: {}: {}", chat_id, e);
                            bot.edit_message_text(
                                waiting_msg.chat.id,
                                waiting_msg.id,
                                format!("‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—Ö–µ–¥–∂–∏—Ä–æ–≤–∞–Ω–∏—è {}: {}", sym, e)
                            ).await?;
                        }
                    }
                }
                 _ => {
                    bot.send_message(chat_id, "‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞. –î–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ —á–∏—Å–ª–æ.").await?;
                }
            }
        }

         Command::Funding(arg) => {
             if let Err(e) = bot.delete_message(chat_id, message_id).await {
                 warn!("Failed to delete user command message {}: {}", message_id, e);
            }
            let parts: Vec<_> = arg.split_whitespace().collect();
            if parts.is_empty() {
                bot.send_message(chat_id, "–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /funding <SYMBOL> [days]").await?;
            } else {
                let sym = parts[0].to_uppercase();
                let days_u32 = parts.get(1).and_then(|s| s.parse::<u32>().ok()).unwrap_or(30); // –ü–∞—Ä—Å–∏–º –∫–∞–∫ u32
                if days_u32 == 0 {
                     bot.send_message(chat_id, "‚ö†Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–Ω–µ–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è.").await?;
                     return Ok(());
                }
                // --- –ò–°–ü–†–ê–í–õ–ï–ù–û: –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º u32 –≤ u16 ---
                let days_u16 = days_u32 as u16; // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ u16 (–¥–ª—è –¥–Ω–µ–π —ç—Ç–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ)

                info!("Fetching funding rate for {} ({} days) for chat_id: {}", sym, days_u16, chat_id);
                // –ü–µ—Ä–µ–¥–∞–µ–º days_u16 –≤ –º–µ—Ç–æ–¥
                match exchange.get_funding_rate(&sym, days_u16).await {
                    Ok(rate) => {
                        bot.send_message(chat_id, format!(
                            "üìà –°—Ä–µ–¥–Ω—è—è —Å—Ç–∞–≤–∫–∞ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è {} –∑–∞ {} –¥–Ω: {:.4}%",
                            sym, days_u16, rate * 100.0, // –ò—Å–ø–æ–ª—å–∑—É–µ–º days_u16 –¥–ª—è –≤—ã–≤–æ–¥–∞
                        )).await?;
                    }
                    Err(e) => {
                         error!("Failed to fetch funding rate for {} for chat_id: {}: {}", sym, chat_id, e);
                        bot.send_message(chat_id, format!("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞–≤–∫—É —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è {}: {}", sym, e)).await?;
                    }
                }
            }
        }
    }
    Ok(())
}
